/// Name of the Azure DataLake Gen2 storage account to pull data from.
expression 'Storage URL' = "https://ftkmicfland5pd7gdo37oozc.dfs.core.windows.net/ingestion" meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type text]
	lineageTag: 421c1232-0e40-45a4-bc59-257ce648478c
	queryGroup: '🛠️ Setup\FinOps hubs'

	annotation PBI_ResultType = Text

	annotation PBI_NavigationStepName = Navigation

expression 'File Type' = ".parquet" meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type text, List = {".parquet", ".gz"}, DefaultValue = ".parquet"]
	lineageTag: 72b5bbfd-a222-4629-b5e5-0d57245f25ff
	queryGroup: '🛠️ Setup\FinOps hubs'

	annotation PBI_ResultType = Text

expression RangeStart = #datetime(2023, 12, 1, 0, 0, 0) meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type datetime]
	lineageTag: 90085870-f708-4bc2-90c1-3a343e88a26b
	queryGroup: '🛠️ Setup\FinOps hubs'

	annotation PBI_ResultType = DateTime

expression RangeEnd = #datetime(2025, 1, 1, 0, 0, 0) meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type datetime]
	lineageTag: 695f1d3b-7b1a-49fa-8d83-f2c25dc787de
	queryGroup: '🛠️ Setup\FinOps hubs'

	annotation PBI_ResultType = DateTime

/// Do you want to connect to the Cost Management connector or a FinOps hubs instance?
expression 'Data Source' = "FinOps hubs" meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type text, List = {"FinOps hubs"}, DefaultValue = "FinOps hus"]
	lineageTag: a3ad5d11-4fa5-425f-8d18-6cdb6822244a
	queryGroup: '🛠️ Setup\Instructions'

	annotation PBI_ResultType = Text

/// Enter the number of months
expression 'Number of Months' = 1 meta [IsParameterQuery = true, IsParameterQueryRequired = false, Type = type number]
	lineageTag: 2ddc095d-bca9-471d-b5e9-70a45facb053
	queryGroup: '🛠️ Setup\CM connector'

	annotation PBI_ResultType = Number

/// Loads data from the configured FinOps hub.
/// 
/// Learn more @ https://aka.ms/finops/hubs
expression ftk_Hub = ```
		(optional datasetType as text, optional startDate as datetime, optional endDate as datetime) =>
		let
		    // Config
		    url     = #"Storage URL",
		    ext     = if Text.Length(#"File Type") > 0 then #"File Type" else ".parquet",
		    start   = if startDate = null then RangeStart else startDate,
		    end     = if endDate = null then RangeEnd else endDate,
		// TODO: Allow pulling other datasets -- if datasetType = null or datasetType = "" then "focuscost" else datasetType
		    dataset = "focuscost",
		
		    ADLS = AzureStorage.DataLake(url),
		    FilterHiddenFiles = Table.SelectRows(ADLS, each [Attributes]?[Hidden]? <> true),
		
		    // Parse folder path
		    Dataset   = Table.AddColumn(FilterHiddenFiles, "Dataset",   each List.Last(List.RemoveLastN(Text.Split([Folder Path],"/"), 1))),
		    Month     = Table.AddColumn(Dataset,           "Month",     each List.Last(List.RemoveLastN(List.RemoveLastN(Text.Split([Folder Path],"/"), 1), 1) )),
		// TODO: Update date handling for raw exports
		    StartDate = Table.AddColumn(Month,             "StartDate", each [Month] & "01"),
		    StartDate_type = Table.TransformColumnTypes(StartDate, {{"StartDate", type date}}),
		    EndDate   = Table.AddColumn(StartDate_type,    "EndDate",   each Date.EndOfMonth([StartDate])),
		
		    // Only FOCUS costs
		// TODO: Get metric from the manifest
		    FilterFilesByMetricAndFileType = Table.SelectRows(EndDate, each [Dataset] = dataset and [Extension] = ext),
		
		    // Only process files for months within the date range
		    FilterFilesByDate =
		        if start = null and end = null then FilterFilesByMetricAndFileType
		        else Table.SelectRows(FilterFilesByMetricAndFileType, each (start = null or [StartDate] >= Date.StartOfMonth(Date.From(start))) and (end = null or [EndDate] <= Date.EndOfMonth(Date.From(end)))),
		
		    // Extract
		    unpack = (zipData) => Table.PromoteHeaders(Csv.Document(Binary.Decompress(zipData, Compression.GZip), [Delimiter=",", Columns=60, Encoding=1252, QuoteStyle=QuoteStyle.Csv, CsvStyle=CsvStyle.QuoteAlways]), [PromoteAllScalars=true]),
		    SelectContent = Table.SelectColumns(FilterFilesByDate, {"Content"}),
		    UnpackContent = Table.AddColumn(SelectContent, "Custom", each if ext = ".gz" then unpack([Content]) else Parquet.Document([Content])),
		    ExpandedColumns = Table.ExpandTableColumn(UnpackContent, "Custom", List.Sort(Table.ColumnNames(List.First(UnpackContent[Custom], null)))),
		    RemovedContent = Table.RemoveColumns(ExpandedColumns, {"Content"}),
		
		    // Only pull from the predefined date range (if specified)
		    tbl = RemovedContent,
		    FilterRowsByDate =
		        if start = null and end = null then tbl
		        else Table.SelectRows(tbl, each
		            (start = null or [ChargePeriodEnd] >= DateTime.From(start))
		            and (end = null or [ChargePeriodStart] < DateTime.From(end))
		        ),
		
		    // TODO: Extract from the manifest
		    _armResourceName = (id) => List.Last(Text.Split(id, "/")),
		    DataSet = Table.AddColumn(FilterRowsByDate, "x_DatasetType", each "FocusCost"),
		    Schema =  Table.AddColumn(DataSet, "x_DatasetVersion", each "1.0-preview(v1)"),
		    AccountType = Table.AddColumn(Schema, "x_AccountType", 
		        each if [BillingAccountId] = [SubAccountId] then "MOSA"
		        else if _armResourceName([BillingAccountId]) = [x_BillingAccountId] then "EA"
		        else if _armResourceName([BillingAccountId]) = [x_BillingProfileId] then (if [InvoiceIssuerName] = "Microsoft" then "MCA" else "MPA")
		        else "Unknown"
		    ),
		
		    Output = AccountType
		in
		    Output
		```
	lineageTag: 1195459e-bb6d-4ef2-8823-5f63c16fbcf5
	queryGroup: '🛠️ Setup\Functions'

	annotation PBI_ResultType = Function

/// Loads FOCUS cost and usage data from the configured FinOps hub.
/// 
/// Learn more @ https://aka.ms/finops/hubs
expression ftk_CostDetails = ```
		(optional start as datetime, optional end as datetime) =>
		let
		    // Get the data
		    rawData = ftk_Hub("focuscost", start, end),
		
		    // Fix types
		    FixTypes = Table.TransformColumnTypes(rawData, {
		        // Date columns
		        {"BillingPeriodEnd",          type datetimezone},
		        {"BillingPeriodStart",        type datetimezone},
		        {"ChargePeriodEnd",           type datetimezone},
		        {"ChargePeriodStart",         type datetimezone},
		        {"x_BillingExchangeRateDate", type datetimezone},
		        {"x_ServicePeriodStart",      type datetimezone},
		        {"x_ServicePeriodEnd",        type datetimezone},
		        // Cost/price columns
		        {"BilledCost",                type number},
		        {"EffectiveCost",             type number},
		        {"ListCost",                  type number},
		        {"ListUnitPrice",             type number},
		        {"x_BilledCostInUsd",         type number},
		        {"x_BilledUnitPrice",         type number},
		        {"x_EffectiveCostInUsd",      type number},
		        {"x_EffectiveUnitPrice",      type number},
		        {"x_OnDemandCost",            type number},
		        {"x_OnDemandCostInUsd",       type number},
		        {"x_OnDemandUnitPrice",       type number},
		        // Other columns
		        {"PricingQuantity",           type number},
		        {"UsageQuantity",             type number},
		        {"x_BillingExchangeRate",     type number},
		        {"x_PartnerCreditRate",       type number},
		        {"x_PricingBlockSize",        type number},
		        {"x_SkuTerm",                 type text}  // Text due to a bug in CM data; converted to a number below
		        // TODO: {"x_SkuIsCreditEligible",   type logical}
		        // TODO: {"x_PartnerCreditApplied",  type logical}
		    }),
		
		    // Helper functions
		    _exists     = (col) => Table.HasColumns(rawData, col),
		    _isMissing  = (col) => _exists(col) = false,
		    _isBlank    = (val) => val = null or val = "",
		    _isNotBlank = (val) => _isBlank(val) = false,
		    _swapCol    = (tbl, oldCol, newCol, newVal, optional newType) => let add = Table.AddColumn(tbl, newCol, newVal, newType), del = if Table.HasColumns(add, oldCol) then Table.RemoveColumns(add, {oldCol}) else add in del,
		    _resetCol   = (tbl, col, newVal, optional newType) => let tmpCol = Text.Combine({"tmp_", col}), tmp = _swapCol(tbl, col, tmpCol, newVal, newType), ren = Table.RenameColumns(tmp, {{tmpCol, col}}) in ren,
		    _parseResourceId = (id, getName) => if _isBlank(id) then null else 
		        let
		            // Handle implicit Microsoft.Resources RP names
		            updatedId = if Text.StartsWith(id, "/subscriptions/") or Text.StartsWith(id, "/tenants/") then "/providers/Microsoft.Resources" & id else id,
		
		            // Parse resource ID segments separately
		            allSegments = Text.Split(List.Last(Text.Split(updatedId, "/providers/")), "/"),
		            provider = allSegments{0},
		            _parseId = (evenOrOdd) => List.RemoveNulls(List.Transform({1..List.Count(allSegments)-1}, each if Number.Mod(_, 2) = evenOrOdd then allSegments{_} else null)),
		            nameSegments = _parseId(0),
		            typeSegments = _parseId(1),
		            
		            // Remove the sub ID if it's a child resource of the subscription
		            isChildOfSubscription = provider = "Microsoft.Resources" and Text.Lower(typeSegments{0}) = "subscriptions" and List.Count(typeSegments) > 1,
		            fullName = Text.Combine((if isChildOfSubscription then List.RemoveFirstN(nameSegments, 1) else nameSegments), "/"),
		
		            fullType = provider & "/" & Text.Combine(typeSegments, "/"),
		            result = if getName then fullName else fullType
		        in
		            result
		    ,
		    _parseResourceName = (id) => _parseResourceId(id, true),
		    _parseResourceType = (id) => _parseResourceId(id, false),
		    
		    // FOCUS "1.0-preview(v1)" bugs
		    SkuTerm = _resetCol(FixTypes, "x_SkuTerm", each if [x_SkuTerm] = "1Year" then 12 else if [x_SkuTerm] = "3Years" then 36 else if [x_SkuTerm] = "5Years" then 60 else Number.FromText([x_SkuTerm]), type number),
		
		    // Parse arrays
		    SkuDetailsDict        = Table.AddColumn(SkuTerm,        "x_SkuDetailsDictionary", each if _isNotBlank([x_SkuDetails]) then Json.Document([x_SkuDetails]) else null),
		    SkuDetailsDict_copy   = Table.AddColumn(SkuDetailsDict, "tmp_SkuDetails",         each [x_SkuDetailsDictionary]),
		    SkuDetailsDict_errors = Table.ReplaceErrorValues(SkuDetailsDict_copy, {{"tmp_SkuDetails", null}}),
		    Tags_backfill         = _resetCol(SkuDetailsDict_errors, "Tags", each if _isBlank([Tags]) then "{}" else [Tags]),
		    TagsDictionary        = Table.AddColumn(Tags_backfill,  "x_TagsDictionary", each if _isNotBlank([Tags]) then Json.Document([Tags]) else null),
		    TagsDictionary_copy   = Table.AddColumn(TagsDictionary, "tmp_Tags",         each [x_TagsDictionary]),
		    TagsDictionary_errors = Table.ReplaceErrorValues(TagsDictionary_copy, {{"tmp_Tags", null}}),
		    ParsedArrays = TagsDictionary_errors,
		
		    // FTK columns
		    Tags_expand  = Table.ExpandRecordColumn(ParsedArrays, "tmp_Tags",
		        {"cm-resource-parent", "ms-resource-parent", "hidden-managedby", "costanalysis-parent", "ftk-version",      "ftk-tool"},
		        {"tmp_cmParent",       "tmp_msParent",       "tmp_ManagedBy",    "tmp_caParent",        "x_ToolkitVersion", "tmp_ToolkitTool"}
		    ),
		    ResourceParentId   = Table.AddColumn(Tags_expand,        "x_ResourceParentId",   
		        each Text.Replace("/" & (if _isNotBlank([tmp_cmParent])  then [tmp_cmParent] 
		        else if _isNotBlank([tmp_msParent])  then [tmp_msParent] 
		        else if _isNotBlank([tmp_ManagedBy]) then [tmp_ManagedBy] 
		        else if _isNotBlank([tmp_caParent])  then [tmp_caParent] 
		        else null), "//", "/")),
		    ResourceParentId_backfill = _resetCol(ResourceParentId,         "x_ResourceParentId",   each if _isBlank([x_ResourceParentId]) then null else [x_ResourceParentId]),
		    ResourceParentType = Table.AddColumn(ResourceParentId_backfill, "x_ResourceParentType", each _parseResourceType([x_ResourceParentId])),
		    ResourceParentName = Table.AddColumn(ResourceParentType,        "x_ResourceParentName", each _parseResourceName([x_ResourceParentId])),
		    Tool = _swapCol(ResourceParentName, "tmp_ToolkitTool", "x_ToolkitTool", 
		        each if _isNotBlank([tmp_ToolkitTool]) then [tmp_ToolkitTool] 
		        else if _isBlank([x_ResourceParentId]) then null 
		        else if Text.Contains(Text.Lower([x_ResourceParentId]), "/providers/microsoft.cloud/hubs/") then "FinOps hubs"
		        else null),
		    ExpandedTags = Table.RemoveColumns(Tool, { "tmp_cmParent", "tmp_msParent", "tmp_caParent", "tmp_ManagedBy" }),
		
		    // AHB columns
		    SkuDetails_expand   = Table.ExpandRecordColumn(ExpandedTags, "tmp_SkuDetails",
		        {"UsageType",      "ImageType",      "ServiceType", "VMName",     "VMProperties",      "VCPUs",       "ReservationOrderId",         "ReservationId",         "VMCapacityReservationId", "AHB",        "vCores"},
		        {"x_SkuUsageType", "x_SkuImageType", "x_SkuType",   "tmp_VMName", "x_SkuVMProperties", "tmp_VMvCPUs", "tmp_AddlReservationOrderId", "tmp_AddlReservationId", "x_CapacityCommitmentId",  "tmp_SQLAHB", "tmp_SQLvCores"}
		    ),
		    SkuDetails_types    = Table.TransformColumnTypes(SkuDetails_expand, {{"tmp_VMvCPUs", Int64.Type}, {"tmp_SQLvCores", Int64.Type}}),
		    ResourceMachineName = _swapCol(SkuDetails_types,           "tmp_VMName",         "x_ResourceMachineName", each if _isNotBlank([tmp_VMName]) then [tmp_VMName] else null),
		    ProductCPUs         = Table.AddColumn(ResourceMachineName, "x_SkuCPUs",          each if [tmp_VMvCPUs] <> null then [tmp_VMvCPUs] else if [tmp_SQLvCores] <> null then [tmp_SQLvCores] else null, Int64.Type),
		    CPUHours            = Table.AddColumn(ProductCPUs,         "x_UsageCPUHours",    each if [x_SkuCPUs] <> null then [x_SkuCPUs] * [UsageQuantity] else null, type number),
		    HybridBenefitStatus = Table.AddColumn(CPUHours,            "x_SkuLicenseStatus", each if _isNotBlank([x_SkuMeterSubcategory]) and Text.Contains([x_SkuMeterSubcategory], "Windows") or [tmp_SQLAHB] = "False" then "Not enabled" else if (_isNotBlank([x_SkuImageType]) and Text.Contains([x_SkuImageType], "Windows Server BYOL")) or [tmp_SQLAHB] = "True" or (_isNotBlank([x_SkuMeterSubcategory]) and Text.Contains([x_SkuMeterSubcategory], "Azure Hybrid Benefit")) then "Enabled" else "Not supported"),
		    HybridBenefitCPUs   = Table.AddColumn(HybridBenefitStatus, "x_SkuLicenseCPUs",   each if [x_SkuCPUs] = null then 0 else if [x_SkuCPUs] <= 8 then 8 else if [x_SkuCPUs] <= 16 then 16 else if [x_SkuCPUs] = 20 then 24 else if [x_SkuCPUs] > 20 then [x_SkuCPUs] else 0, type number),
		// TODO: Add SQL AHB handling
		    AHB = Table.RemoveColumns(HybridBenefitCPUs, { "tmp_AddlReservationOrderId", "tmp_AddlReservationId", "tmp_SQLAHB", "tmp_SQLvCores", "tmp_VMvCPUs" }),
		
		    // Commitment metadata
		    CommitmentDiscountKey          = Table.AddColumn(AHB,                            "x_CommitmentDiscountKey",          each [x_SkuType] & [x_SkuMeterId]),
		    CommitmentUtilizationPotential = Table.AddColumn(CommitmentDiscountKey,          "x_CommitmentUtilizationPotential", each if [CommitmentDiscountCategory] = "Usage" then [UsageQuantity] else if [CommitmentDiscountCategory] = "Spend" then [EffectiveCost] else 0, type number),
		    CommitmentUtilizationAmount    = Table.AddColumn(CommitmentUtilizationPotential, "x_CommitmentUtilizationAmount",    each if [ChargeSubcategory] = "Used Commitment" then [x_CommitmentUtilizationPotential] else 0, type number),
		    Commitments = CommitmentUtilizationAmount,
		
		    // Savings calculations
		    CommitmentUnitPriceSavings = Table.AddColumn(Commitments,                "x_CommitmentUnitPriceSavings", each if [x_OnDemandUnitPrice] > 0 and [x_OnDemandUnitPrice] >= [x_EffectiveUnitPrice] then [x_OnDemandUnitPrice] - [x_EffectiveUnitPrice] else null, type number),
		    NegotiatedUnitPriceSavings = Table.AddColumn(CommitmentUnitPriceSavings, "x_NegotiatedUnitPriceSavings", each if [ListUnitPrice]       > 0 and [ListUnitPrice]       >= [x_OnDemandUnitPrice]  then [ListUnitPrice]       - [x_OnDemandUnitPrice]  else null, type number),
		    DiscountUnitPriceSavings   = Table.AddColumn(NegotiatedUnitPriceSavings, "x_DiscountUnitPriceSavings",   each if [ListUnitPrice]       > 0 and [ListUnitPrice]       >= [x_EffectiveUnitPrice] then [ListUnitPrice]       - [x_EffectiveUnitPrice] else null, type number),
		    CommitmentCostSavings      = Table.AddColumn(DiscountUnitPriceSavings,   "x_CommitmentCostSavings",      each if _isBlank([CommitmentDiscountCategory]) then 0 else if [x_OnDemandCost] > 0 and [x_OnDemandCost] >= [EffectiveCost] then [x_OnDemandCost] - [EffectiveCost] else null, type number),
		    NegotiatedCostSavings      = Table.AddColumn(CommitmentCostSavings,      "x_NegotiatedCostSavings",      each if [ListCost]            > 0 and [ListCost]            >= [x_OnDemandCost]       then [ListCost]            - [x_OnDemandCost] else null, type number),
		    DiscountCostSavings        = Table.AddColumn(NegotiatedCostSavings,      "x_DiscountCostSavings",        each if [ListCost]            > 0 and [ListCost]            >= [EffectiveCost]        then [ListCost]            - [EffectiveCost]  else if [x_OnDemandCost] > 0 and [x_OnDemandCost] >= [EffectiveCost] then [x_OnDemandCost] - [EffectiveCost] else null, type number),
		    Savings = DiscountCostSavings,
		
		    // Data cleansing
		    FreeReason = Table.AddColumn(Savings, "x_FreeReason", 
		        each if [BilledCost] <> 0.0 or [EffectiveCost] <> 0.0 then null
		        else if [PricingCategory] = "Commitment-Based" then "Unknown " & [ChargeSubcategory]
		        else if [x_BilledUnitPrice] = 0.0 and [x_EffectiveUnitPrice] = 0.0 and [x_OnDemandUnitPrice] = 0.0 and [ListUnitPrice] = 0.0 and _isBlank([CommitmentDiscountType]) then (
		            if _isNotBlank([x_SkuDescription]) and Text.Contains([x_SkuDescription], "Trial") then "Trial" else if _isNotBlank([x_SkuDescription]) and Text.Contains([x_SkuDescription], "Preview") then "Preview" else "Other"
		        )
		        else if [x_BilledUnitPrice] > 0.0 or [x_EffectiveUnitPrice] > 0.0 then (
		            if [PricingQuantity] > 0.0 then "Low Usage" else if [PricingQuantity] = 0.0 then "No Usage" else "Unknown Negative Quantity"
		        )
		        else "Unknown"),
		    // TODO: BUG: SkuId == SkuPriceId for EA???
		
		    // Unique names -- Must be after ResourceName cleanup and Commitment columns
		// TODO: Only add differentiators when the name is not unique
		    CommitmentDiscountNameUnique = Table.AddColumn(FreeReason,                   "CommitmentDiscountNameUnique", each if _isBlank([CommitmentDiscountId]) then null else [CommitmentDiscountName] & " (" & [CommitmentDiscountType] & ")"),
		    ResourceNameUnique           = Table.AddColumn(CommitmentDiscountNameUnique, "ResourceNameUnique",           each if _isBlank([ResourceId])           then null else [ResourceName] & " (" & [ResourceType] & ")"),
		    ResourceGroupNameUnique      = Table.AddColumn(ResourceNameUnique,           "x_ResourceGroupNameUnique",    each if _isBlank([x_ResourceGroupName])  then null else [x_ResourceGroupName] & " (" & [SubAccountName] & ")"),
		    SubscriptionNameUnique       = Table.AddColumn(ResourceGroupNameUnique,      "SubAccountNameUnique",         each if _isBlank([SubAccountId])         then null else [SubAccountName] & " (" & _parseResourceName([SubAccountId]) & ")"),
		    Names = SubscriptionNameUnique,
		
		    // Month column
		    Month = Table.AddColumn(Names, "x_Month", each DateTime.Date(Date.StartOfMonth([ChargePeriodStart])), type date),
		
		    // Unique key for the record -- WARNING: This increases the data size significantly.
		    /*
		    _addIdSegment = (val) => (if _isNotBlank(val) then "-" & val else ""),
		    ChargeId = Table.AddColumn(Month, "x_ChargeId", each Text.Combine(List.RemoveItems({
		        Date.ToText([ChargePeriodStart]),
		        [x_BillingAccountId],
		        if [x_BillingProfileId] = [x_BillingAccountId] then null else [x_BillingProfileId], // Only add BP if not the same as the BA (all EA)
		        [x_InvoiceSectionId],
		        if _isNotBlank([ResourceId]) and Text.Contains([ResourceId], [x_SubscriptionId]) then null else [x_SubscriptionId], // Only add sub if not in the resource ID
		        [ResourceId],
		        [tmp_ResourceLocation],
		        [x_SkuOfferId],
		        [SkuPriceId],
		        [x_SkuMeterId],
		        [x_SkuPartNumber],
		        if _isBlank([CommitmentDiscountId]) then null else List.Last(Text.Split([CommitmentDiscountId], "/")),
		        [x_CostAllocationRuleName],
		        [x_CostCenter],
		        if _isBlank([Tags])                 then null else Text.Remove([Tags], {"{","""","}"}),
		        if _isBlank([x_SkuDetails])         then null else Text.Remove([x_SkuDetails], {"{","""","}"})
		    }, {null, ""}), "-")),
		    */
		
		    // Sort columns alphabetically
		    Output = Table.ReorderColumns(Month, List.Sort(Table.ColumnNames(Month)))
		in
		    Output
		```
	lineageTag: 5727ddf9-c3a6-4ac6-ad56-75d31af50502
	queryGroup: '🛠️ Setup\Functions'

	annotation PBI_ResultType = Function

	annotation PBI_NavigationStepName = Navigation

expression '▶️  START HERE' = ```
		let
		    SourceType = #"Data Source",
		    IsExpors = SourceType = "Cost Management exports",
		    IsHubs = SourceType = "FinOps hubs",
		    SourceCheck = 
		        if SourceType = "" then {"✖ Missing", "Please select either the Cost Mangaement connector or FinOps hubs as a data source."}
		        else {"✔️ Specified", "Connecting to the " & SourceType & "."},
		
		    // Storage
		    StorageUrl = #"Storage URL",
		    StorageCheck = 
		        if StorageUrl = "" or StorageUrl = null then {"✖ Missing", "Please specify the storage URL."}
		        else if Text.StartsWith(StorageUrl, "https://") = false or Text.EndsWith(StorageUrl, "/ingestion") = false then {"✖ Invalid", "Please check your storage URL."}
		        else {"✔️ Specified", "Will pull costs from " & Splitter.SplitTextByAnyDelimiter({"/", "."})(StorageUrl){2} & "."},
		
		    // Incremental refresh
		    DateStart = RangeStart,
		    DateEnd = RangeEnd,
		    DateCheck = 
		        if DateStart = null then {"✖ Missing", "Please specify the start date."}
		        else if DateEnd = null then {"✖ Missing", "Please specify the end date."}
		        else if DateStart > DateEnd then {"✖ Invalid", "The start date must be before the end date."}
		        else {"✔️ Specified", "Will pull costs for " & Number.ToText(Duration.Days(DateEnd - DateStart)) & " days."},
		
		    // Connector
		    ScopeType = if Scope = "" or Scope = null then "" else if Text.Contains(Scope, "-") then "MCA" else "EA",
		    ScopeCheck = 
		        if ScopeType = "" then {"✖ Missing", "Please specify an EA enrollment number or MCA scope ID."}
		        else if ScopeType = "MCA" then (
		            if Text.StartsWith(Text.Lower(Scope), "/providers/microsoft.billing/billingaccounts/") = false then {"✖ Invalid", "Please specify a fully-qualified scope ID to connect to an MCA account."}
		            else if Text.Contains(Text.Lower(Scope), "/billingprofiles/") then {"✔️ Specified", "Connecting to MCA billing profile."}
		            else {"✖ Invalid", "Please specify a billing profile to include reservation recommendations."}
		        )
		        else {"✔️ Specified", "Connecting to EA enrollment " & Scope & "."},
		    TypeCheck = 
		        if ScopeType = "EA" then (if Type = "Enrollment Number" then {"✔️ Specified", "Connecting to an EA account."} else {"✖ Invalid", "Type must be 'Enrollment Number' for EA accounts."})
		        else if ScopeType = "MCA" then (if Type = "Manually Input Scope" then {"✔️ Specified", "Connecting to an MCA account."} else {"✖ Invalid", "Type must be 'Manually Input Scope' for MCA accounts."})
		        else if Type = "Enrollment Number" then {"✔️ Specified", "Expecting an EA account. Please specify the Scope parameter."}
		        else if Type = "Manually Input Scope" then {"✔️ Specified", "Expecting an MCA account. Please specify the Scope parameter."}
		        else {"✖ Invalid", "Please select a Type value."},
		    Months = #"Number of Months",
		    MonthCheck = 
		        if Months = "" or Months = null then {"✖ Missing", "Please specify the number of months to include."}
		        else if Months < 0 then {"✖ Invalid", "Please specify 0 for only the current month or 1+ to include one or more previous months."}
		        else {"✔️ Specified", "Will get data for " & Text.From(Months) & (if Months = 1 then " month." else " months.")},
		
		    // 
		    /*
		    Step1 = Table.InsertRows(#table({"Instructions", "Value", "Status", "Message"}, {}), 0, {
		        [ Instructions = "① Set the data source parameter on the left", Value = SourceType, Status = SourceCheck{0}, Message = SourceCheck{1} ],
		        [ Instructions = "        ➖ About exports @ https://aka.ms/finops/toolkit/exports", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ About FinOps hubs @ https://aka.ms/finops/hubs", Value = "", Status = "", Message = "" ],
		        [ Instructions = "", Value = "", Status = "", Message = "" ]
		    }),
		
		    MainChecks = Table.InsertRows(Step1, 4, 
		    */
		
		    MainChecks = Table.InsertRows(#table({"Instructions", "Value", "Status", "Message"}, {}), 0, {
		        [ Instructions = "① Set the storage URL parameter on the left", Value = StorageUrl, Status = StorageCheck{0}, Message = StorageCheck{1} ],
		        [ Instructions = "        ➖ Go to your hub resource group", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ Open Deployments > `hub` > Outputs", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ Copy the 'storageUrlForPowerBI' value", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "② Set the start/end dates", Value = DateTime.ToText(DateStart, [Format="MMM d, yyyy"]) & " - " & DateTime.ToText(DateEnd, [Format="MMM d, yyyy"]), Status = DateCheck{0}, Message = DateCheck{1} ],
		        [ Instructions = "        ➖ NOTE: Power BI can only support ~$16M in cost details!", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "The following are only needed for reservation recommendations", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "③ Set the Scope parameter on the left", Value = Scope, Status = ScopeCheck{0}, Message = ScopeCheck{1} ],
		        [ Instructions = "        ➖ If using EA, set it to your enrollment number", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ If using MCA, use the following steps to set your scope ID", Value = "", Status = "", Message = "" ],
		        [ Instructions = "              1. Go to https://aka.ms/costmgmt/config", Value = "", Status = "", Message = "" ],
		        [ Instructions = "              2. Change scope to the desired billing profile", Value = "", Status = "", Message = "" ],
		        [ Instructions = "              3. Select the Properties tile", Value = "", Status = "", Message = "" ],
		        [ Instructions = "              4. Use the 'ID' and 'Billing account ID' values to generate the scope ID", Value = "", Status = "", Message = "Example: /providers/Microsoft.Billing/billingAccounts/<id>/billingProfiles/<id>" ],
		        [ Instructions = "                   NOTE: Billing profile is required for MCA reservation recommendations", Value = "", Status = "", Message = "" ],
		        [ Instructions = "              5. Save the value in 'CM connector' > 'Scope'", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "④ Set the Type parameter based on your account type", Value = Type, Status = TypeCheck{0}, Message = TypeCheck{1} ],
		        [ Instructions = "        ➖ For EA, use 'Enrollment Number'", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ For MCA, use 'Manually Input Scope'", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ This value is required for the Cost Management connector", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ", Value = "", Status = "", Message = "" ],
		        [ Instructions = "⑤ Set the number of months to include (more = slower load time)", Value = Months, Status = MonthCheck{0}, Message = MonthCheck{1} ],
		        [ Instructions = "        ➖ 0  = current month only", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ 1  = current month and 1 previous month", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ 2+ = current month and 2+ previous months", Value = "", Status = "", Message = "" ],
		        [ Instructions = "        ➖ NOTE: Power BI can only support ~$16M in cost details!", Value = "", Status = "", Message = "" ]
		    })
		in
		    MainChecks
		```
	lineageTag: 6cfe80b8-1c4b-4c11-9916-43fc98b49dac
	queryGroup: '🛠️ Setup\Instructions'

	annotation PBI_ResultType = Table

	annotation PBI_NavigationStepName = Navigation

/// Loads data from the configured FinOps hubs instance or from a billing account using the Cost Management connector.
/// datasets = 0 (Actual cost), 1 (Amortized cost), 2 (Both)
expression ftk_CMConnector =
		(optional dataset) =>
		let
		    Connector = AzureCostManagement.Tables(Type, Scope, #"Number of Months", []),
		    Data = if dataset = "" or dataset = null then Connector else Connector{[Key=dataset]}[Data]
		in
		    Data
	lineageTag: 9fcc7fe0-336d-49fd-9a77-eeb57b2f7aef
	queryGroup: '🛠️ Setup\Functions'

	annotation PBI_ResultType = Function

/// Enter your EA enrollment number or fully-qualified MCA billing profile resource ID. You must have at least read access to use Power BI. For more options, please use https://aka.ms/finops/hubs.
expression Scope =
		let
		    Source = "8611537" meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type text]
		in
		    Source
	lineageTag: 244a1951-f3fa-4d07-913e-c5770a195267
	queryGroup: '🛠️ Setup\CM connector'

	annotation PBI_ResultType = Text

/// Select "Enrollment Number" if using EA; otherwise, select "Manually Input Scope". These values are required in order to refresh data from the connector in the Power BI service.
expression Type =
		let
		    Source = "Enrollment Number" meta [IsParameterQuery = true, IsParameterQueryRequired = true, Type = type text, List = {"Enrollment Number", "Manually Input Scope"}, DefaultValue = "Enrollment Number"]
		in
		    Source
	lineageTag: e700b3d3-f2af-45a3-af15-199df0040f7b
	queryGroup: '🛠️ Setup\CM connector'

	annotation PBI_ResultType = Text

expression HubData = ```
		let
		    ADLS = AzureStorage.DataLake(#"Storage URL" & "/.."),
		    Storage   = Table.AddColumn(ADLS, "StorageAccount", each Text.SplitAny([Folder Path], "/."){2}),
		    Container = Table.AddColumn(Storage, "Container", each Text.Split([Folder Path], "/"){3}),
		    MonthStr  = Table.AddColumn(Container, "MonthStr", 
		        each if [Container] = "ingestion" then List.Last(List.RemoveLastN(Text.Split(Text.Trim([Folder Path], "/"), "/"), 1))
		        else if [Container] = "msexports" then Text.Range((
		            if Text.Contains(List.Last(List.RemoveLastN(Text.Split(Text.Trim([Folder Path], "/"), "/"), 1)), "-") then List.Last(List.RemoveLastN(Text.Split(Text.Trim([Folder Path], "/"), "/"), 1))
		            else List.Last(List.RemoveLastN(Text.Split(Text.Trim([Folder Path], "/"), "/"), 2))
		        ), 0, 6)
		        else null
		    ),
		    _toMonth = (s) => Date.FromText(Text.Range(s, 0, 4) & "-" & Text.Range(s, 4, 2) & "-01"),
		    // TODO: If we use UTC, it shows up as the previous month -- DateTime.Date(DateTime.FromText(Text.Range(s, 0, 4) & "-" & Text.Range(s, 4, 2) & "-01T00:00:00Z")),
		    Month     = Table.AddColumn(MonthStr, "Month", each if [MonthStr] <> null then _toMonth([MonthStr]) else null, type date),
		    Scope     = Table.AddColumn(Month, "Scope", 
		        each if [Container] = "ingestion" then Text.Split(Text.Split([Folder Path], "/" & [Container]){1}, "/" & [MonthStr]){0} 
		        else if [Container] = "msexports" then Text.Combine(List.RemoveLastN(Text.Split(Text.Split(Text.Split([Folder Path], "/" & [Container]){1}, "/" & [MonthStr]){0}, "/"), 1), "/")
		        else null
		    ),
		    FileType  = Table.AddColumn(Scope, "FileType", 
		        each if [Container] = "config" and [Name] = "settings.json" then [Name]
		        else if [Container] = "ingestion" and [Extension] = ".parquet" then "Ingestion Parquet"
		        else if [Container] = "msexports" and [Name] = "manifest.json" then "Export Manifest"
		        else if [Container] = "msexports" and [Name] = "_manifest.json" then "Export Manifest"
		        else if [Container] = "msexports" and [Extension] = ".csv" then "Exported CSV"
		        else "Unknown"
		    ),
		    IngestionParquet = Table.AddColumn(FileType,         "IngestionParquet", each if [FileType] = "Ingestion Parquet" then 1 else 0),
		    ExportManifest   = Table.AddColumn(IngestionParquet, "ExportManifest",   each if [FileType] = "Export Manifest" then 1 else 0),
		    ExportedCsv      = Table.AddColumn(ExportManifest,   "ExportedCsv",      each if [FileType] = "Exported CSV" then 1 else 0),
		    Manifest = Table.AddColumn(ExportedCsv, "Manifest", 
		        each if [Name] = "manifest.json" then Json.Document([Content])
		        //else if [Name] = "_manifest.json" then Json.Document([Content]) 
		        //else if [Name] = "settings.json" then Json.Document([Content]) 
		        else null
		    ),
		    ExportName  = Table.AddColumn(Manifest, "ExportName", 
		        each if [Name] = "manifest.json" then [Manifest][exportConfig][exportName] 
		        else if [Container] = "msexports" then Text.Split(List.Last(Text.Split([Folder Path], [Scope] & "/")), "/"){0}
		        else null
		    ),
		    ApiVersion  = Table.AddColumn(ExportName, "ApiVersion", 
		        each if [Name] = "manifest.json" then [Manifest][exportConfig][apiVersion] 
		        // else if [Name] = "_manifest.json" then [Manifest][manifestVersion] 
		        else null
		    ),
		    //TimeFrame   = Table.AddColumn(ApiVersion, "TimeFrame", each if [Name] = "manifest.json" then [Manifest][exportConfig][timeFrame] else null),
		    //Granularity = Table.AddColumn(TimeFrame, "Granularity", each if [Name] = "manifest.json" then [Manifest][exportConfig][granularity] else null),
		    Dataset     = Table.AddColumn(ApiVersion, "Dataset", 
		        each if [Container] = "ingestion" then List.Last(Text.Split(Text.Trim([Folder Path], "/"), "/"))
		        else if [Name] = "manifest.json" then Text.Lower([Manifest][exportConfig][type])
		        // else if [Name] = "_manifest.json" then "amortizedcost (assumed)"
		        else null
		    ),
		    // DataVersion   = Table.AddColumn(Dataset,      "DataVersion", each if [Name] = "manifest.json" then [Manifest][exportConfig][dataVersion] else null),
		    // Partitioning  = Table.AddColumn(DataVersion,  "Partitioning", each if [Name] = "manifest.json" then [Manifest][deliveryConfig][partitionData] else null),
		    // ExportFormat  = Table.AddColumn(Partitioning, "ExportFormat", each if [Name] = "manifest.json" then [Manifest][deliveryConfig][fileFormat] else null),
		    // ExportPath    = Table.AddColumn(ExportFormat, "ExportPath", each if [Name] = "manifest.json" then [Manifest][deliveryConfig][rootFolderPath] else null),
		    // ExportedBytes = Table.AddColumn(ExportPath,   "ExportedBytes", 
		    //     each if [Name] = "manifest.json" then List.Sum(List.Transform([Manifest][blobs], each _[byteCount]))
		    //     else if [Name] = "_manifest.json" then [Manifest][byteCount]
		    //     else null
		    // ),
		    // ExportedRows = Table.AddColumn(ExportedBytes, "ExportedRows", each if [Name] = "manifest.json" then null else if [Name] = "_manifest.json" then [Manifest][dataRowCount] else null),
		    // Sorted       = Table.Sort(ExportedRows, {{"Month", Order.Descending}}),
		    GroupBy      = Table.Group(Dataset, {
		        "StorageAccount", "Container", "Scope", "Month", "Dataset", //"DataVersion", //"FileType", //"Folder Path", 
		        "ExportName"//, "TimeFrame", "Granularity", "Partitioning", "ExportFormat", "ExportPath" // "ApiVersion", 
		    }, {
		        {"ApiVersion", each List.First(List.RemoveNulls([ApiVersion]), null), type text},
		        {"IngestionParquet", each List.Sum([IngestionParquet]), Int64.Type},
		        {"ExportManifest", each List.Sum([ExportManifest]), Int64.Type},
		        {"ExportedCsv", each List.Sum([ExportedCsv]), Int64.Type},
		        //{"Files", each Table.RowCount(_), Int64.Type},
		        //{"Size", each List.Sum([Attributes][Size]), Int64.Type},
		        //{"ExportedBytes", each List.Sum([ExportedBytes]), Int64.Type},
		        //{"ExportedRows", each List.Sum([ExportedRows]), Int64.Type},
		        //{"Created", each List.Min([Date created]), type nullable datetime}, 
		        {"Updated", each List.Max([Date modified]), type nullable datetime}, 
		        {"Accessed", each List.Max([Date accessed]), type nullable datetime}
		    })
		in
		    GroupBy
		```
	lineageTag: 35620d01-0ec7-41a6-9fc3-037b8f96dcd9
	queryGroup: 'FinOps toolkit'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression 'Errors in HubExports' =
		let
		Source = HubExports,
		  #"Detected Type Mismatches" = let
		    tableWithOnlyPrimitiveTypes = Table.SelectColumns(Source, Table.ColumnsOfType(Source, {type nullable number, type nullable text, type nullable logical, type nullable date, type nullable datetime, type nullable datetimezone, type nullable time, type nullable duration})),
		    recordTypeFields = Type.RecordFields(Type.TableRow(Value.Type(tableWithOnlyPrimitiveTypes))),
		    fieldNames = Record.FieldNames(recordTypeFields),
		    fieldTypes = List.Transform(Record.ToList(recordTypeFields), each [Type]),
		    pairs = List.Transform(List.Positions(fieldNames), (i) => {fieldNames{i}, (v) => if v = null or Value.Is(v, fieldTypes{i}) then v else error [Message = "The type of the value does not match the type of the column.", Detail = v], fieldTypes{i}})
		in
		    Table.TransformColumns(Source, pairs),
		  #"Added Index" = Table.AddIndexColumn(#"Detected Type Mismatches", "Row Number" ,1),
		  #"Kept Errors" = Table.SelectRowsWithErrors(#"Added Index", {"Scope", "ExportName", "Dataset", "ApiVersion", "StorageAccount", "Container", "Month", "FileType", "FileName", "FileSizeInGB", "FolderPath", "DateCreated", "DateModified", "DateAccessed"}),
		  #"Reordered Columns" = Table.ReorderColumns(#"Kept Errors", {"Row Number", "Scope", "ExportName", "Dataset", "ApiVersion", "StorageAccount", "Container", "Month", "FileType", "FileName", "FileSizeInGB", "FolderPath", "DateCreated", "DateModified", "DateAccessed"})
		in
		  #"Reordered Columns"
	lineageTag: 245a6468-222d-4c5c-afec-5f3d0c3e35a0
	queryGroup: 'Query Errors - 6/6/2024 1:48:22 PM'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression 'Errors in HubIngestion' =
		let
		Source = HubIngestion,
		  #"Detected Type Mismatches" = let
		    tableWithOnlyPrimitiveTypes = Table.SelectColumns(Source, Table.ColumnsOfType(Source, {type nullable number, type nullable text, type nullable logical, type nullable date, type nullable datetime, type nullable datetimezone, type nullable time, type nullable duration})),
		    recordTypeFields = Type.RecordFields(Type.TableRow(Value.Type(tableWithOnlyPrimitiveTypes))),
		    fieldNames = Record.FieldNames(recordTypeFields),
		    fieldTypes = List.Transform(Record.ToList(recordTypeFields), each [Type]),
		    pairs = List.Transform(List.Positions(fieldNames), (i) => {fieldNames{i}, (v) => if v = null or Value.Is(v, fieldTypes{i}) then v else error [Message = "The type of the value does not match the type of the column.", Detail = v], fieldTypes{i}})
		in
		    Table.TransformColumns(Source, pairs),
		  #"Added Index" = Table.AddIndexColumn(#"Detected Type Mismatches", "Row Number" ,1),
		  #"Kept Errors" = Table.SelectRowsWithErrors(#"Added Index", {"Scope", "StorageAccount", "Container", "Dataset", "Month", "FileType", "Files", "SizeInGB", "FolderPath", "Created", "Updated", "Accessed"}),
		  #"Reordered Columns" = Table.ReorderColumns(#"Kept Errors", {"Row Number", "Scope", "StorageAccount", "Container", "Dataset", "Month", "FileType", "Files", "SizeInGB", "FolderPath", "Created", "Updated", "Accessed"})
		in
		  #"Reordered Columns"
	lineageTag: 8b1addc6-c810-4da3-8651-8e09346185c4
	queryGroup: 'Query Errors - 6/6/2024 1:48:22 PM'

